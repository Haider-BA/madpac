#include "peano/integration/partitioncoupling/builtin/PartitionCoupling4MovingSphere.h"


tarch::logging::Log
peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::_log(
  "peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere"
);


void peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::advance(double dt){
  assertion(_receiveData != NULL);
  assertion(_sendData != NULL);
  // no sphere movement, if this should not be done yet
  if (_timestepCounter < _fixSphereForTimesteps){
    // reset accumulated forces in sendData
    _sendData->resetForces();
    _timestepCounter++;
    return;
  }

  // update variables and write updates back to send- and receive classes TODO ------------------------
  // get forces
  _translationalForce = _sendData->getTranslationalForce();
  const tarch::la::Vector<3,double> torque(_sendData->getTorque());
  tarch::la::Vector<3,double> omega(getOmega(_momentOfInertia,_orientation,_angularMomentum));
  const tarch::la::Matrix<3,3,double> starOmega(starOp(omega));
  tarch::la::Matrix<3,3,double> result(0.0);

  // testing
  _translationalForces.push_back(_translationalForce);
  _torques.push_back(torque);


  logDebug("advance()", "Torque: " << torque);
  logDebug("advance()", "Translation: " << _translationalForce);
  // update angular/translational momentum,orientation and position  by expl. euler
  _translationalMomentum += dt*_translationalForce;
  _angularMomentum += dt*torque;
  tarch::la::multiply(starOmega,_orientation,result);
  for (int i = 0; i < 3; i ++){
    for (int j = 0; j < 3; j++){
      _orientation(i,j) += dt*result(i,j);
    }
  }
  for (int d = 0; d < DIMENSIONS; d++){
    _position(d) += (dt/_mass)*_translationalMomentum(d);
  }
  // compute new angular velocity
  omega = getOmega(_momentOfInertia,_orientation,_angularMomentum);
  // reset accumulated forces in sendData and set correct position again
  _sendData->resetForces();
  _sendData->setPosition(_position);

  // set new translational momentum, angular velocity and position in receiveData
  _receiveData->setPosition(_position);
  _receiveData->setTranslationalVelocity((1.0/_mass)*_translationalMomentum);
  _receiveData->setAngularVelocity(omega);

  // for testing
  _translationalVelocities.push_back((1.0/_mass)*_translationalMomentum);
  _angularVelocities.push_back(omega);


  // create new sphere
  peano::geometry::builtin::Sphere *sphere = new peano::geometry::builtin::Sphere(true,_radius,_position);
  assertion(sphere != NULL);
  assertion(_intersection != NULL);
  // replace old sphere by new sphere in intersection
  _intersection->replaceGeometry(_spherePositionInIntersectionVector,sphere);

  // plot output if needed
  plotVTK(omega);
  plotPovray(omega,dt);

  // increment timestep counter
  _timestepCounter++;
}


void peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::
plotVTK(const tarch::la::Vector<3,double>& omega) const {
  if (_plotVTK
#ifdef Parallel
      && tarch::parallel::Node::getInstance().isMasterProcess()
#endif
  ){
    if ( (_timestepCounter%_timestepsPerPlottingVTK == 0) ){
      std::stringstream ss(std::stringstream::in | std::stringstream::out);
      ss << _filename << _timestepCounter << ".vtk";
      std::string filename(ss.str());
      std::ofstream file;
      file.open(filename.c_str());


      if (!file.is_open()){
        logInfo("plotVTK()","Could not open file " << filename);
        assertion1(false, "Could not open file " << filename);
      }
      // write header
      file << "# vtk DataFile Version 2.0" << std::endl;
      file << "Generated by Peano2 Author: Philipp Neumann" << std::endl;
      file << "ASCII" << std::endl << std::endl;
      file << "DATASET UNSTRUCTURED_GRID" << std::endl;

      // write sphere position
      file << "POINTS 1 float" << std::endl;
      for (int d = 0; d < DIMENSIONS-1; d++){
        file << _position(d) << "  ";
      }
      file << _position(DIMENSIONS-1);
#if (DIMENSIONS==2)
      file << "  0.0" << std::endl << std::endl;
#elif (DIMENSIONS==3)
      file << std::endl << std::endl;
#else
#error "Only 2D/3D supported"
#endif

      // write radius for scaling
      file << "POINT_DATA 1" << std::endl;
      file << "SCALARS diameter float 1" << std::endl << "LOOKUP_TABLE default" << std::endl;
      file << 2.0*_radius << std::endl << std::endl;

      // write translational sphere velocity
      file << "VECTORS translationalVelocity float" << std::endl;
      for (int d = 0; d < DIMENSIONS-1; d++){
        file << (1.0/_mass)*_translationalMomentum(d) << "  ";
      }
      file << (1.0/_mass)*_translationalMomentum(DIMENSIONS-1);
#if (DIMENSIONS==2)
      file << "  0.0" << std::endl << std::endl;

#elif (DIMENSIONS==3)
      file << std::endl << std::endl;
#else
#error "Only 2D/3D supported"
#endif

      // write angular sphere velocity
      file << "VECTORS angularVelocity float" << std::endl;
#if (DIMENSIONS==3)
      file << omega(0) << "  " << omega(1) << "  " << omega(2) << std::endl;
#elif (DIMENSIONS==2)
      file << omega(0) << "  " << "0.0  0.0" << std::endl;
#endif
      file << std::endl << std::endl;

      file << "VECTORS translationalForce float" << std::endl;
#if (DIMENSIONS==3)
      file << _translationalForce(0) << "  " << _translationalForce(1) << "  " << _translationalForce(2) << std::endl;
#elif (DIMENSIONS==2)
      file << _translationalForce(0) << "  " << _translationalForce(1) << "  0.0" << std::endl;
#endif
      file << std::endl << std::endl;

      // close file
      file.close();
    }
  }
}


void peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::
plotPovray(const tarch::la::Vector<3,double>& omega,const double& dt) {
  if (_plotPovray
#ifdef Parallel
      && tarch::parallel::Node::getInstance().isMasterProcess()
#endif
  ){
    tarch::la::Vector<3,double> angle(0.0);
    _angleForPovray = _angleForPovray + dt*omega;

    angle = (360.0/(2.0*tarch::la::PI*_radius))*_angleForPovray;

    if ( (_timestepCounter%_timestepsPerPlottingPovray == 0) ){
      std::stringstream ss(std::stringstream::in | std::stringstream::out);
      char numBuf[50];
      sprintf(numBuf,"%010d",_timestepCounter);
      ss << _filename << numBuf << ".pov";
      std::string filename(ss.str());
      std::ofstream file;
      file.open(filename.c_str());


      if (!file.is_open()){
        logInfo("plotPovray()", "Could not open file " << filename);
        assertion1(false, "Could not open file " << filename);
      }

      // includes
      file << "#include \"colors.inc\"" << std::endl;
      file << "#include \"textures.inc\"" << std::endl;
      file << "#include \"finish.inc\"" << std::endl;
      file << "#include \"stones.inc\"" << std::endl;

      // background and camera
      file << std::endl << "background {color Grey}" << std::endl;
      file << std::endl << "camera {" << std::endl;
      file << "  location <" << _domainOffset(0)+0.5*_domainSize(0) << ",";
#if (DIMENSIONS==2)
      file << _domainOffset(1)+0.5*_domainSize(1) << ",";
      file << "0.0>" << std::endl;
#elif (DIMENSIONS==3)
      file << _domainOffset(2)+0.5*_domainSize(2) << ",";
      file << _domainOffset(1) << ">" << std::endl;
#endif

      file << "  look_at <" << _position(0) << ",";
#if (DIMENSIONS==2)
      file << _position(1) << ",";
      file << 0.5*std::sqrt(_domainSize(0)*_domainSize(0)+_domainSize(1)*_domainSize(1)) << ">" << std::endl;
#elif(DIMENSIONS==3)
      file << _position(2) << ",";
      file << _position(1) << ">" << std::endl;
#endif
      file << "}" << std::endl << std::endl;


      // sphere
      file << "sphere {" << std::endl;

      // put sphere at origin first
      file << "  <0.0,0.0,0.0> " << _radius << std::endl;
      file << "  texture {" << std::endl;
      file << "    T_Grnt9" << std::endl;
      //file << "    pigment { checker rgb <1,0,0>, rgb <1,1,0> scale " << 0.1*_radius << "}" << std::endl;
//      file << "    pigment{ hexagon color rgb<1,1,1>*1.0 color rgb<1,1,1>*0.0 color rgb<1,1,1>*0.5" << std::endl;
//      file << "    scale <0.115/pi,0.25/pi,0.075>*" << 1.65 << std::endl;
//      file << "    warp { spherical orientation <0,1,0> }" << std::endl;
//      file << "    scale " << 0.175*_radius << "}" << std::endl;
      file << "  }" << std::endl;

      // rotate sphere
#if (DIMENSIONS==2)
      file << "  rotate <" << angle(0) << "," << angle(1) << "," << angle(2) << ">" << std::endl;
#elif (DIMENSIONS==3)
      file << "  rotate <" << angle(0) << "," << angle(2) << "," << angle(1) << ">" << std::endl;
#endif
      // translate sphere to correct position
      file << "  translate <" << _position(0) << ",";
#if (DIMENSIONS==2)
      file << _position(1) << ",";
      file << 0.5*std::sqrt(_domainSize(0)*_domainSize(0)+_domainSize(1)*_domainSize(1)) << "> " << std::endl;
#elif(DIMENSIONS==3)
      file << _position(2) << ",";
      file << _position(1) << "> " <<  std::endl;
#endif
      file << "}" << std::endl << std::endl;

      file << "plane {" << std::endl;
      file << "  <0,1,0>,0 pigment { checker rgb <0,0,0>, rgb <1,1,1> }" << std::endl;
      file << "  translate<" << _domainOffset(0) << ",";
#if (DIMENSIONS==2)
      file << _domainOffset(1) << ",0.0>" << std::endl;
#elif (DIMENSIONS==3)
      file << _domainOffset(2) << "," << _domainOffset(1) << ">" << std::endl;
#endif
      file << "}" << std::endl << std::endl;



      // light sources
      file <<  "light_source { ";
      file << "<" << _domainOffset(0)-_domainSize(0) << ",";
#if (DIMENSIONS==2)
      file << _domainOffset(1)+2.0*_domainSize(1) << ",";
      file << "0.0>";
#elif (DIMENSIONS==3)
      file << _domainOffset(2)+2.0*_domainSize(2) << ",";
      file << _domainOffset(1)-_domainSize(1) << ">";
#endif
      file << " color White}" << std::endl;

      file <<  "light_source { ";
      file << "<" << _domainOffset(0)+2.0*_domainSize(0) << ",";
#if (DIMENSIONS==2)
      file << _domainOffset(1)+2.0*_domainSize(1) << ",";
      file << "0.0>";
#elif (DIMENSIONS==3)
      file << _domainOffset(2)+2.0*_domainSize(2) << ",";
      file << _domainOffset(1)-_domainSize(1) << ">";
#endif
      file << " color White}" << std::endl;

      file <<  "light_source { ";
      file << "<" << _domainOffset(0)+0.5*_domainSize(0) << ",";
#if (DIMENSIONS==2)
      file << _domainOffset(1)-_domainSize(1) << ",";
      file << "0.0>";
#elif (DIMENSIONS==3)
      file << _domainOffset(2)-_domainSize(2) << ",";
      file << _domainOffset(1)-_domainSize(1) << ">";
#endif
      file << " color White}" << std::endl;

      file.close();
    }
  }
}


void peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::initialize(){
  assertion(_basicGeometry != NULL);
  peano::geometry::builtin::Sphere *sphere = new peano::geometry::builtin::Sphere(true,_radius,_position);
  assertion(sphere != NULL);

  _intersection = new peano::geometry::Intersection();
  assertion(_intersection != NULL);
  _intersection->addGeometry(_basicGeometry);
  // store position of sphere in intersection vector
  _spherePositionInIntersectionVector = _intersection->addGeometry(sphere);

  // set this geometry in geometry service
  peano::geometry::services::GeometryService::getInstance().init(_intersection,true);

  // set initial positions (actually not necessary; should have already happened in initialisation of these services)
  _receiveData = static_cast<peano::integration::partitioncoupling::builtin::ReceiveDataFromMovingSphere*> (&peano::integration::partitioncoupling::services::ReceiveDataService::getInstance().getReceiveData());
  assertion(_receiveData != NULL);
  _receiveData->setPosition(_position);
  _sendData = static_cast<peano::integration::partitioncoupling::builtin::SendDataToMovingSphere*> (&peano::integration::partitioncoupling::services::SendDataService::getInstance().getSendData());
  assertion(_sendData != NULL);
  _sendData->setPosition(_position);
  _sendData->resetForces();

}


void peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::finalize(){}



tarch::la::Matrix<3,3,double>
peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::
starOp(const tarch::la::Vector<3,double> &vec) const {
  tarch::la::Matrix<3,3,double> star(0.0);
  star(0,1) = -vec(2);
  star(0,2) =  vec(1);
  star(1,0) =  vec(2);
  star(1,2) = -vec(0);
  star(2,0) = -vec(1);
  star(2,1) =  vec(0);
  return star;
}


tarch::la::Vector<3,double>
peano::integration::partitioncoupling::builtin::PartitionCoupling4MovingSphere::getOmega(
  const tarch::la::Matrix<3,3,double> &momentOfInertia,
  const tarch::la::Matrix<3,3,double> &orientation,
  const tarch::la::Vector<3,double> &angularMomentum
) const {
  tarch::la::Vector<3,double>   omega(0.0);
  tarch::la::Matrix<3,3,double> inertiaTensor(0.0);
  tarch::la::Matrix<3,3,double> orientationTranspose(0.0);
  tarch::la::Matrix<3,3,double> buf(0.0);

  // determine transpose of orientation
  for (int i = 0; i < 3; i++){
    for (int j = 0; j < 3; j++){
      orientationTranspose(i,j) = orientation(j,i);
    }
  }
  // buf = I_body*R_transpose
  tarch::la::multiply(momentOfInertia,orientationTranspose,buf);
  // I =  R*(I_body*R_transpose)
  tarch::la::multiply(orientation,buf,inertiaTensor);

  // solve I*omega=angMomentum
  tarch::la::solveSystem3x3(inertiaTensor,angularMomentum,omega);

  return omega;
}
