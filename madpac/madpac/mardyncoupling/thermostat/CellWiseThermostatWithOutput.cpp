/***************************************************************************
 *   Copyright (C) 2011 by Peter Hoffmann <peter.hoffmann@mytum.de>        *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "CellWiseThermostatWithOutput.h"

#include <iostream>
#include <fstream>
#include <string>

namespace madpac
{

  namespace mardyncoupling
  {

    namespace thermostat
    {

      CellWiseThermostatWithOutput::CellWiseThermostatWithOutput(
          int dim,
          ParticleContainer* moleculeContainer,
          Domain* domain,
          ExchangeDataContainer *dataContainer,
          int streamOutDir,
          madpac::mardyncoupling::configurations::MarDynCellWiseThermostatWithOutputConfiguration* config) :
        CellWiseThermostat(dim, moleculeContainer, domain, dataContainer,
            streamOutDir, config)
      {
        std::cout << "CWTWO" << std::endl;
        _filename = config->getOutputFile();
        _ointerval = config->getOutputInterval();
      }

      CellWiseThermostatWithOutput::~CellWiseThermostatWithOutput()
      {
      }

      void
      CellWiseThermostatWithOutput::applyThermostat(int iteration)
      {
        saveV();
        //std::cout << "asdxsa" << std::endl;
        if (_ginterval != 0 && iteration % _ginterval == 0)
          {
            updateGlobalE();
          }

        if (_interval != 0 && iteration % _interval == 0)
          {
            updateLocalE();
            if (_ointerval != 0 && iteration % _ointerval == 0)
              writeOutput(_filename, iteration);
            adjustTemperature();
          }

      }

      void
      CellWiseThermostatWithOutput::writeOutput(const std::string& filename,
          int iteration)
      {
        std::stringstream strstr;
        strstr << filename << "_" << (iteration < 10 ? "000"
            : (iteration < 100 ? "00" : (iteration < 1000 ? "0" : "")))
            << iteration << ".vtk";

        std::ofstream file(strstr.str().c_str());

        file << "# vtk DataFile Version 2.0" << std::endl;
        file << "generated by madpac" << std::endl;
        file << "ASCII" << std::endl;

        file << std::endl;
        file << "DATASET STRUCTURED_GRID" << std::endl;
        file << "DIMENSIONS  " << _size[X] << " " << _size[Y] << " "
            << _size[Z] << std::endl;
        file << "POINTS  " << _size[X] * _size[Y] * _size[Z] << " float"
            << std::endl;
        for (int i = 0; i < _size[X]; i++)
          for (int j = 0; j < _size[Y]; j++)
            for (int k = 0; k < _size[Z]; k++)
              {
                file << i << " " << j << " " << k << std::endl;
              }
        file << std::endl;
        file << std::endl;
        file << std::endl;
        file << "POINT_DATA  " << _size[X] * _size[Y] * _size[Z] << std::endl;
        file << "SCALARS density float 1" << std::endl;
        file << "LOOKUP_TABLE default" << std::endl;
        for (int i = 0; i < _size[X]; i++)
          for (int j = 0; j < _size[Y]; j++)
            for (int k = 0; k < _size[Z]; k++)
              {
                file << _vPerCell[calcIndexX(i, j, k)][DataContainer::rho]
                    << std::endl;
              }

        file << std::endl;
        file << std::endl;
        file << std::endl;
        file << "SCALARS energy float 1" << std::endl;
        file << "LOOKUP_TABLE default" << std::endl;
        for (int i = 0; i < _size[X]; i++)
          for (int j = 0; j < _size[Y]; j++)
            for (int k = 0; k < _size[Z]; k++)
              {
                file << _ePerCell[calcIndexX(i, j, k)] << std::endl;
              }

        file << std::endl;
        file << std::endl;
        file << std::endl;
        file << "VECTORS velocity float" << std::endl;
        for (int i = 0; i < _size[X]; i++)
          for (int j = 0; j < _size[Y]; j++)
            for (int k = 0; k < _size[Z]; k++)
              {
                int index = calcIndexX(i, j, k);
                double vx = _vPerCell[index][DataContainer::velocityX];
                double vy = _vPerCell[index][DataContainer::velocityY];
                double vz = _vPerCell[index][DataContainer::velocityZ];
                if (vx != vx || vx > 999999999999 || vx < -999999999999)
                  vx = 0;
                if (vy != vy || vy > 999999999999 || vy < -999999999999)
                  vy = 0;
                if (vz != vz || vz > 999999999999 || vz < -999999999999)
                  vz = 0;

                file << vx << " " << vy << " " << vz << std::endl;
              }

      }

    }

  }

}
