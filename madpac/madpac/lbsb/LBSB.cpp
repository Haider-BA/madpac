/***************************************************************************
 *   Copyright (C) 2011 by Peter Hoffmann <peter.hoffmann@mytum.de>        *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "LBSB.h"
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
using namespace std;

utils::Vector<utils::Vector<double,2> ,9> c;
utils::Vector<double,9> a;
double lb2ms = 901.0;
int LBSB::getNumObj() {
	 return _xsize*_ysize;
}
/*
void LBSB::execHyWriter(outputWriter::VTKWriter fileWriter, double cellSize, double xOffset,
		double yOffset, double lb2md, bool drawInner) {
	//int k = 0;
	for(int i=0;i<_xsize;i++)
			for(int j=0;j<_ysize;j++)
				if(drawInner || i < _xsize/2+xOffset+_borderSize || i >= _xsize/2-xOffset-_borderSize || j < _ysize/2+yOffset+_borderSize || j >= _ysize/2-yOffset-_borderSize)
						fileWriter.plotCell(_p,_v,i,j,cellSize,xOffset,yOffset,lb2md);
				/*else {k++;
				std::cout <<"i"<< i<<"j"<<j << std::endl;
				}
	std::cout <<"k"<< k << std::endl;*//*
 }

void LBSB::writeOutput(const std::string& filename, int iteration) {
	_fileWriter.initializeOutput(_xsize*_ysize);
	for(int i=0;i<_xsize;i++)
		for(int j=0;j<_ysize;j++)
			_fileWriter.plotCell(_p,_v,i,j,1,0,0,1);
	_fileWriter.writeFile(filename, iteration);
}
*/

void LBSB::writeOutput(const std::string& filename, int iteration) {
	stringstream strstr;
	strstr << filename << "_" << (iteration < 10 ? "000" : (iteration < 100 ? "00" : ( iteration < 1000 ? "0" : "") )) << iteration << ".vtk";

	std::ofstream file(strstr.str().c_str());

	file << "# vtk DataFile Version 2.0" << std::endl;
	file << "generated by MaD LaB ;)" << std::endl;
	file << "ASCII" << std::endl;

	file  << std::endl;
	file << "DATASET STRUCTURED_GRID" << std::endl;
	file << "DIMENSIONS  " << _xsize<< " " <<_ysize<<" 1" << std::endl;
	file << "POINTS  " << _xsize*_ysize<<" float" << std::endl;
	for(int i=0;i<_xsize;i++)
		for(int j=0;j<_ysize;j++) {
			file << i << " " << j << " " << "0"<<std::endl;
		}
	file  << std::endl;
	file  << std::endl;
	file  << std::endl;
	file << "POINT_DATA  " << _xsize*_ysize << std::endl;
	file << "SCALARS density float 1" << std::endl;
	file << "LOOKUP_TABLE default" << std::endl;
	for(int i=0;i<_xsize;i++)
		for(int j=0;j<_ysize;j++) {
			file << _p->get(i,j) <<std::endl;
		}
	file  << std::endl;
	file  << std::endl;
	file  << std::endl;
	file << "VECTORS velocity float" << std::endl;
	for(int i=0;i<_xsize;i++)
			for(int j=0;j<_ysize;j++) {
				file << (_v->get(i,j)[0]*lb2ms) <<" "<< (_v->get(i,j)[1]*lb2ms) << " "<< "0.0" <<std::endl;
			}


}

LBSB::LBSB(double rho, double t, int xsize, int ysize, bool wave, dataContainer *hDataContainer) : _xsize(xsize), _ysize(ysize), tau(1.0), _wave(wave), iteration(0), _dataContainer(hDataContainer) {
	double energy = xsize*ysize * t/901.0;
	double velocity = 2.0 * energy / (double)(2 * xsize*ysize);
	//LOG4CXX_TRACE(logger, "Calculated velocity of " << velocity);
	double meanVelocity = sqrt(velocity);

	int ci[9][2] = {{0,0},{0,-1},{0,1},{-1,0},{1,0},{-1,-1},{-1,1},{1,-1},{1,1}};
	for(int i=0;i<9;i++) {
		c[i][0] = ci[i][0];
		c[i][1] = ci[i][1];
		a[i] = 4.0/9.0;
					if(i>4)
						a[i] = 1.0/36.0;
					else if (i>0)
						a[i] = 1.0/9.0;
	}

	_p = new OffsetArray<double>(_xsize,_ysize);
	_v = new OffsetArray<utils::Vector<double,2> >(_xsize,_ysize);
	_f = new OffsetArray<double>*[9];
	for(int i=0;i<9;i++)
			_f[i] = new OffsetArray<double>(_xsize,_ysize);

	double Amp2 = 0.1;
	double Width = 10;
	for(int i=0;i<_xsize;i++)
		for(int j=0;j<_ysize;j++) {
			_p->get(i,j) = rho;//1+Amp2*exp(-(pow(i-_xsize/2,2)+pow(j-_ysize/2,2))/Width);//rho;
			/*for (int k = 0; k < 2; k++) {
				_v->get(i,j)[k] = meanVelocity/2.0- meanVelocity * GaussDeviate();
				//std::cout << _v->get(i,j)[k] << std::endl;
			}*/
			_v->get(i,j)[0] = meanVelocity;
			_v->get(i,j)[1] = 0.0;
			for (int k = 0; k < 9; k++)
				_f[k]->get(i,j) =a[k]*rho;
		}
}

LBSB::~LBSB() {
	delete _p;
	delete _v;
	delete[] _f;

}

void LBSB::setXV(double v) {
	for(int i=0;i<_xsize;i++)
		for(int j=0;j<_ysize;j++)
			_v->get(i,j)[0] = v;
}

/*
void LBSB::getBoundaryCells(std::vector<utils::Vector<int, 3> >& v, int deltaA, int deltaB) {
	for(int i=deltaA;i<_xsize-deltaA;i++) {
		for(int j=deltaA;j<_ysize-deltaA;j++) {
			if(i <= deltaB || _xsize-deltaB-1 <= i || j <= deltaB || _ysize-deltaB-1 <= j) {
				int tmp[3] = {i,j,0};
				v.push_back(tmp);
			}
		}
	}
	std::sort(v.begin(),v.end());
}
/*
utils::Vector<double, 3> LBSB::getV(utils::Vector<int, 3> cell) {
	utils::Vector<double, 3> ve  = 0.0;
	ve[0] = _v->get(cell[0],cell[1])[0];
	ve[1] = _v->get(cell[0],cell[1])[1];
	double lb2ms = 901.0;
	return ve*lb2ms;
}
	void LBSB::setV(utils::Vector<double, 3> ve, utils::Vector<int, 3> cell) {
		double ms2lb = 1.0/901.0;
		_v->get(cell[0],cell[1])[0] = ve[0]*ms2lb;
		_v->get(cell[0],cell[1])[1] = ve[1]*ms2lb;

	}*/
void LBSB::getNsetV(bool first) {

	int tmpIndex[3];
	tmpIndex[2] =0;
	double tmpData[4];
	for(int i=0;i<_xsize;i++) {
		tmpIndex[0] = i;
		for(int j=0;j<_ysize;j++) {
			tmpIndex[1] = j;

			if(!first && _dataContainer->getMDData4LB(tmpData,tmpIndex)) {
				assert(tmpData[0] == tmpData[0]);
			//	std::cout << i << " "<< tmpIndex[0] << " "<<j<<" " << tmpIndex[1] << " " << tmpData[0] << " " << tmpData[1] << std::endl;
				for(int k=0;k<2;k++)
					_v->get(i,j)[k] = tmpData[k]/lb2ms;
				//_p->get(i,j) = tmpData[dataContainer::rho];
			}

			for(int k=0;k<2;k++)
				tmpData[k] = _v->get(i,j)[k]*lb2ms;
			tmpData[2] = 0;
			tmpData[3] = _p->get(i,j);
			_dataContainer->setLBRegion(tmpData,tmpIndex);
		}
	}
}

void LBSB::calcV() {
	for(int i=0;i<_xsize;i++)
		for(int j=0;j<_ysize;j++) {
			_p->get(i,j) = 0.0;
			_v->get(i,j) = 0.0;
			for(int k=0;k<9;k++) {
				double f_k = _f[k]->get(i,j);

				_p->get(i,j) += f_k;
				_v->get(i,j) = _v->get(i,j) + (c[k]*f_k);
				assert(_v->get(i,j) == _v->get(i,j));
			}
			_v->get(i,j) = _v->get(i,j)* (1.0/_p->get(i,j));
		}


}
void LBSB::clacF() {

	utils::Vector<double, 2> F = 0.0;
	F[0] = 0.000001;
	double cs2 = 1.0/3.0;
	for(int i=0;i<_xsize;i++) {
		for(int j=0;j<_ysize;j++) {
			double vsq = _v->get(i,j)*_v->get(i,j);
			for(int k=0;k<9;k++) {
				double CiV = c[k]*_v->get(i,j);
				double Feq = a[k]*_p->get(i,j)*(1+CiV/cs2+CiV*CiV/(2*cs2*cs2)-vsq/2/cs2);

				_f[k]->get(i,j) = _f[k]->get(i,j) - 1/tau*(_f[k]->get(i,j)-Feq);
				double Fplus =  a[k]*(c[k]*F/cs2+c[k]*F/(2*cs2*cs2)-F*F/2/cs2);
			//	if(_wave && i==3 && iteration<1)
				//	_f[k]->get(i,j) += Fplus;


				//std::cout << "CiV" << CiV << " " << (ai*_p->get(i,j)) << "F " << Feq << std::endl;
			}
		}
	}
	for(int i=0;i<9;i++)
		_f[i]->modOffset(c[i]);
	if(_wave && iteration<10)
		for(int i=0;i<_xsize;i++) {
			for(int j=0;j<_ysize;j++) {
					if(i==2) {
						std::cout << _f[4]->get(i,j);
						_f[4]->get(i,j) += 300.0;
						std::cout << " "<<_f[4]->get(i,j)<<std::endl;


					}

			}
		}

	iteration++;
}

double LBSB::GaussDeviate() {
	double a1, a2, s, r, b1;
	static int iset = 0;
	static double b2;

	if (!iset) {
		do {
			a1 = 2.0 * rand() / (RAND_MAX + 1.0) - 1.0;
			a2 = 2.0 * rand() / (RAND_MAX + 1.0) - 1.0;
			r = a1 * a1 + a2 * a2;
		} while (r >= 1.0);
		s = sqrt(-2.0 * log(r) / r);
		b1 = a1 * s;
		b2 = a2 * s;
		iset = 1;
		return b1;
	} else {
		iset = 0;
		return b2;
	}
}
