// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ConfigFile.hxx"

// boundaryType
// 

boundaryType::
boundaryType (value v)
: ::xml_schema::string (_xsd_boundaryType_literals_[v])
{
}

boundaryType::
boundaryType (const char* v)
: ::xml_schema::string (v)
{
}

boundaryType::
boundaryType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

boundaryType::
boundaryType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

boundaryType::
boundaryType (const boundaryType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

boundaryType& boundaryType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_boundaryType_literals_[v]);

  return *this;
}


// coordinate
// 

coordinate::
coordinate (value v)
: ::xml_schema::string (_xsd_coordinate_literals_[v])
{
}

coordinate::
coordinate (const char* v)
: ::xml_schema::string (v)
{
}

coordinate::
coordinate (const ::std::string& v)
: ::xml_schema::string (v)
{
}

coordinate::
coordinate (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

coordinate::
coordinate (const coordinate& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

coordinate& coordinate::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_coordinate_literals_[v]);

  return *this;
}


// dimension
// 

dimension::
dimension (::xml_schema::int_ v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v)
{
}

dimension::
dimension (const dimension& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v, f, c)
{
}


// thermostatType
// 

const thermostatType::change_optional& thermostatType::
change () const
{
  return this->change_;
}

thermostatType::change_optional& thermostatType::
change ()
{
  return this->change_;
}

void thermostatType::
change (const change_type& x)
{
  this->change_.set (x);
}

void thermostatType::
change (const change_optional& x)
{
  this->change_ = x;
}

void thermostatType::
change (::std::auto_ptr< change_type > x)
{
  this->change_.set (x);
}

const thermostatType::initialTemperature_type& thermostatType::
initialTemperature () const
{
  return this->initialTemperature_.get ();
}

thermostatType::initialTemperature_type& thermostatType::
initialTemperature ()
{
  return this->initialTemperature_.get ();
}

void thermostatType::
initialTemperature (const initialTemperature_type& x)
{
  this->initialTemperature_.set (x);
}

const thermostatType::frequency_type& thermostatType::
frequency () const
{
  return this->frequency_.get ();
}

thermostatType::frequency_type& thermostatType::
frequency ()
{
  return this->frequency_.get ();
}

void thermostatType::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}


// materialType
// 

const materialType::epsilon_type& materialType::
epsilon () const
{
  return this->epsilon_.get ();
}

materialType::epsilon_type& materialType::
epsilon ()
{
  return this->epsilon_.get ();
}

void materialType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const materialType::sigma_type& materialType::
sigma () const
{
  return this->sigma_.get ();
}

materialType::sigma_type& materialType::
sigma ()
{
  return this->sigma_.get ();
}

void materialType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const materialType::mass_type& materialType::
mass () const
{
  return this->mass_.get ();
}

materialType::mass_type& materialType::
mass ()
{
  return this->mass_.get ();
}

void materialType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


// cuboidType
// 

const cuboidType::material_type& cuboidType::
material () const
{
  return this->material_.get ();
}

cuboidType::material_type& cuboidType::
material ()
{
  return this->material_.get ();
}

void cuboidType::
material (const material_type& x)
{
  this->material_.set (x);
}

void cuboidType::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}

const cuboidType::x0_type& cuboidType::
x0 () const
{
  return this->x0_.get ();
}

cuboidType::x0_type& cuboidType::
x0 ()
{
  return this->x0_.get ();
}

void cuboidType::
x0 (const x0_type& x)
{
  this->x0_.set (x);
}

const cuboidType::x1_type& cuboidType::
x1 () const
{
  return this->x1_.get ();
}

cuboidType::x1_type& cuboidType::
x1 ()
{
  return this->x1_.get ();
}

void cuboidType::
x1 (const x1_type& x)
{
  this->x1_.set (x);
}

const cuboidType::x2_type& cuboidType::
x2 () const
{
  return this->x2_.get ();
}

cuboidType::x2_type& cuboidType::
x2 ()
{
  return this->x2_.get ();
}

void cuboidType::
x2 (const x2_type& x)
{
  this->x2_.set (x);
}

const cuboidType::v0_type& cuboidType::
v0 () const
{
  return this->v0_.get ();
}

cuboidType::v0_type& cuboidType::
v0 ()
{
  return this->v0_.get ();
}

void cuboidType::
v0 (const v0_type& x)
{
  this->v0_.set (x);
}

const cuboidType::v1_type& cuboidType::
v1 () const
{
  return this->v1_.get ();
}

cuboidType::v1_type& cuboidType::
v1 ()
{
  return this->v1_.get ();
}

void cuboidType::
v1 (const v1_type& x)
{
  this->v1_.set (x);
}

const cuboidType::v2_type& cuboidType::
v2 () const
{
  return this->v2_.get ();
}

cuboidType::v2_type& cuboidType::
v2 ()
{
  return this->v2_.get ();
}

void cuboidType::
v2 (const v2_type& x)
{
  this->v2_.set (x);
}

const cuboidType::n0_type& cuboidType::
n0 () const
{
  return this->n0_.get ();
}

cuboidType::n0_type& cuboidType::
n0 ()
{
  return this->n0_.get ();
}

void cuboidType::
n0 (const n0_type& x)
{
  this->n0_.set (x);
}

const cuboidType::n1_type& cuboidType::
n1 () const
{
  return this->n1_.get ();
}

cuboidType::n1_type& cuboidType::
n1 ()
{
  return this->n1_.get ();
}

void cuboidType::
n1 (const n1_type& x)
{
  this->n1_.set (x);
}

const cuboidType::n2_type& cuboidType::
n2 () const
{
  return this->n2_.get ();
}

cuboidType::n2_type& cuboidType::
n2 ()
{
  return this->n2_.get ();
}

void cuboidType::
n2 (const n2_type& x)
{
  this->n2_.set (x);
}

const cuboidType::h_type& cuboidType::
h () const
{
  return this->h_.get ();
}

cuboidType::h_type& cuboidType::
h ()
{
  return this->h_.get ();
}

void cuboidType::
h (const h_type& x)
{
  this->h_.set (x);
}


// change
// 

const change::target_type& change::
target () const
{
  return this->target_.get ();
}

change::target_type& change::
target ()
{
  return this->target_.get ();
}

void change::
target (const target_type& x)
{
  this->target_.set (x);
}

const change::stepping_type& change::
stepping () const
{
  return this->stepping_.get ();
}

change::stepping_type& change::
stepping ()
{
  return this->stepping_.get ();
}

void change::
stepping (const stepping_type& x)
{
  this->stepping_.set (x);
}

const change::steppingFrequency_type& change::
steppingFrequency () const
{
  return this->steppingFrequency_.get ();
}

change::steppingFrequency_type& change::
steppingFrequency ()
{
  return this->steppingFrequency_.get ();
}

void change::
steppingFrequency (const steppingFrequency_type& x)
{
  this->steppingFrequency_.set (x);
}


// config
// 

const config::gravity_optional& config::
gravity () const
{
  return this->gravity_;
}

config::gravity_optional& config::
gravity ()
{
  return this->gravity_;
}

void config::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void config::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

void config::
gravity (::std::auto_ptr< gravity_type > x)
{
  this->gravity_.set (x);
}

const config::container_type& config::
container () const
{
  return this->container_.get ();
}

config::container_type& config::
container ()
{
  return this->container_.get ();
}

void config::
container (const container_type& x)
{
  this->container_.set (x);
}

void config::
container (::std::auto_ptr< container_type > x)
{
  this->container_.set (x);
}

const config::domain_type& config::
domain () const
{
  return this->domain_.get ();
}

config::domain_type& config::
domain ()
{
  return this->domain_.get ();
}

void config::
domain (const domain_type& x)
{
  this->domain_.set (x);
}

void config::
domain (::std::auto_ptr< domain_type > x)
{
  this->domain_.set (x);
}

const config::timedata_type& config::
timedata () const
{
  return this->timedata_.get ();
}

config::timedata_type& config::
timedata ()
{
  return this->timedata_.get ();
}

void config::
timedata (const timedata_type& x)
{
  this->timedata_.set (x);
}

void config::
timedata (::std::auto_ptr< timedata_type > x)
{
  this->timedata_.set (x);
}

const config::thermostat_optional& config::
thermostat () const
{
  return this->thermostat_;
}

config::thermostat_optional& config::
thermostat ()
{
  return this->thermostat_;
}

void config::
thermostat (const thermostat_type& x)
{
  this->thermostat_.set (x);
}

void config::
thermostat (const thermostat_optional& x)
{
  this->thermostat_ = x;
}

void config::
thermostat (::std::auto_ptr< thermostat_type > x)
{
  this->thermostat_.set (x);
}

const config::output_type& config::
output () const
{
  return this->output_.get ();
}

config::output_type& config::
output ()
{
  return this->output_.get ();
}

void config::
output (const output_type& x)
{
  this->output_.set (x);
}

void config::
output (::std::auto_ptr< output_type > x)
{
  this->output_.set (x);
}

const config::inputfile_sequence& config::
inputfile () const
{
  return this->inputfile_;
}

config::inputfile_sequence& config::
inputfile ()
{
  return this->inputfile_;
}

void config::
inputfile (const inputfile_sequence& s)
{
  this->inputfile_ = s;
}

const config::inputcuboid_sequence& config::
inputcuboid () const
{
  return this->inputcuboid_;
}

config::inputcuboid_sequence& config::
inputcuboid ()
{
  return this->inputcuboid_;
}

void config::
inputcuboid (const inputcuboid_sequence& s)
{
  this->inputcuboid_ = s;
}

const config::inputfcc_sequence& config::
inputfcc () const
{
  return this->inputfcc_;
}

config::inputfcc_sequence& config::
inputfcc ()
{
  return this->inputfcc_;
}

void config::
inputfcc (const inputfcc_sequence& s)
{
  this->inputfcc_ = s;
}

const config::inputsphere_sequence& config::
inputsphere () const
{
  return this->inputsphere_;
}

config::inputsphere_sequence& config::
inputsphere ()
{
  return this->inputsphere_;
}

void config::
inputsphere (const inputsphere_sequence& s)
{
  this->inputsphere_ = s;
}

const config::boundary_sequence& config::
boundary () const
{
  return this->boundary_;
}

config::boundary_sequence& config::
boundary ()
{
  return this->boundary_;
}

void config::
boundary (const boundary_sequence& s)
{
  this->boundary_ = s;
}

const config::dim_type& config::
dim () const
{
  return this->dim_.get ();
}

config::dim_type& config::
dim ()
{
  return this->dim_.get ();
}

void config::
dim (const dim_type& x)
{
  this->dim_.set (x);
}

void config::
dim (::std::auto_ptr< dim_type > x)
{
  this->dim_.set (x);
}

const config::statistics_type& config::
statistics () const
{
  return this->statistics_.get ();
}

config::statistics_type& config::
statistics ()
{
  return this->statistics_.get ();
}

void config::
statistics (const statistics_type& x)
{
  this->statistics_.set (x);
}


// gravity
// 

const gravity::factor_type& gravity::
factor () const
{
  return this->factor_.get ();
}

gravity::factor_type& gravity::
factor ()
{
  return this->factor_.get ();
}

void gravity::
factor (const factor_type& x)
{
  this->factor_.set (x);
}

const gravity::axis_type& gravity::
axis () const
{
  return this->axis_.get ();
}

gravity::axis_type& gravity::
axis ()
{
  return this->axis_.get ();
}

void gravity::
axis (const axis_type& x)
{
  this->axis_.set (x);
}

void gravity::
axis (::std::auto_ptr< axis_type > x)
{
  this->axis_.set (x);
}


// container
// 

const container::type_type& container::
type () const
{
  return this->type_.get ();
}

container::type_type& container::
type ()
{
  return this->type_.get ();
}

void container::
type (const type_type& x)
{
  this->type_.set (x);
}

void container::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const container::cutoff_type& container::
cutoff () const
{
  return this->cutoff_.get ();
}

container::cutoff_type& container::
cutoff ()
{
  return this->cutoff_.get ();
}

void container::
cutoff (const cutoff_type& x)
{
  this->cutoff_.set (x);
}


// domain
// 

const domain::size_x_type& domain::
size_x () const
{
  return this->size_x_.get ();
}

domain::size_x_type& domain::
size_x ()
{
  return this->size_x_.get ();
}

void domain::
size_x (const size_x_type& x)
{
  this->size_x_.set (x);
}

const domain::size_y_type& domain::
size_y () const
{
  return this->size_y_.get ();
}

domain::size_y_type& domain::
size_y ()
{
  return this->size_y_.get ();
}

void domain::
size_y (const size_y_type& x)
{
  this->size_y_.set (x);
}

const domain::size_z_type& domain::
size_z () const
{
  return this->size_z_.get ();
}

domain::size_z_type& domain::
size_z ()
{
  return this->size_z_.get ();
}

void domain::
size_z (const size_z_type& x)
{
  this->size_z_.set (x);
}


// timedata
// 

const timedata::delta_type& timedata::
delta () const
{
  return this->delta_.get ();
}

timedata::delta_type& timedata::
delta ()
{
  return this->delta_.get ();
}

void timedata::
delta (const delta_type& x)
{
  this->delta_.set (x);
}

const timedata::end_type& timedata::
end () const
{
  return this->end_.get ();
}

timedata::end_type& timedata::
end ()
{
  return this->end_.get ();
}

void timedata::
end (const end_type& x)
{
  this->end_.set (x);
}


// output
// 

const output::filebase_type& output::
filebase () const
{
  return this->filebase_.get ();
}

output::filebase_type& output::
filebase ()
{
  return this->filebase_.get ();
}

void output::
filebase (const filebase_type& x)
{
  this->filebase_.set (x);
}

void output::
filebase (::std::auto_ptr< filebase_type > x)
{
  this->filebase_.set (x);
}

const output::frequency_type& output::
frequency () const
{
  return this->frequency_.get ();
}

output::frequency_type& output::
frequency ()
{
  return this->frequency_.get ();
}

void output::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}


// inputfile
// 

const inputfile::name_type& inputfile::
name () const
{
  return this->name_.get ();
}

inputfile::name_type& inputfile::
name ()
{
  return this->name_.get ();
}

void inputfile::
name (const name_type& x)
{
  this->name_.set (x);
}

void inputfile::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// inputsphere
// 

const inputsphere::material_type& inputsphere::
material () const
{
  return this->material_.get ();
}

inputsphere::material_type& inputsphere::
material ()
{
  return this->material_.get ();
}

void inputsphere::
material (const material_type& x)
{
  this->material_.set (x);
}

void inputsphere::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}

const inputsphere::x0_type& inputsphere::
x0 () const
{
  return this->x0_.get ();
}

inputsphere::x0_type& inputsphere::
x0 ()
{
  return this->x0_.get ();
}

void inputsphere::
x0 (const x0_type& x)
{
  this->x0_.set (x);
}

const inputsphere::x1_type& inputsphere::
x1 () const
{
  return this->x1_.get ();
}

inputsphere::x1_type& inputsphere::
x1 ()
{
  return this->x1_.get ();
}

void inputsphere::
x1 (const x1_type& x)
{
  this->x1_.set (x);
}

const inputsphere::x2_type& inputsphere::
x2 () const
{
  return this->x2_.get ();
}

inputsphere::x2_type& inputsphere::
x2 ()
{
  return this->x2_.get ();
}

void inputsphere::
x2 (const x2_type& x)
{
  this->x2_.set (x);
}

const inputsphere::v0_type& inputsphere::
v0 () const
{
  return this->v0_.get ();
}

inputsphere::v0_type& inputsphere::
v0 ()
{
  return this->v0_.get ();
}

void inputsphere::
v0 (const v0_type& x)
{
  this->v0_.set (x);
}

const inputsphere::v1_type& inputsphere::
v1 () const
{
  return this->v1_.get ();
}

inputsphere::v1_type& inputsphere::
v1 ()
{
  return this->v1_.get ();
}

void inputsphere::
v1 (const v1_type& x)
{
  this->v1_.set (x);
}

const inputsphere::v2_type& inputsphere::
v2 () const
{
  return this->v2_.get ();
}

inputsphere::v2_type& inputsphere::
v2 ()
{
  return this->v2_.get ();
}

void inputsphere::
v2 (const v2_type& x)
{
  this->v2_.set (x);
}

const inputsphere::n_type& inputsphere::
n () const
{
  return this->n_.get ();
}

inputsphere::n_type& inputsphere::
n ()
{
  return this->n_.get ();
}

void inputsphere::
n (const n_type& x)
{
  this->n_.set (x);
}

const inputsphere::h_type& inputsphere::
h () const
{
  return this->h_.get ();
}

inputsphere::h_type& inputsphere::
h ()
{
  return this->h_.get ();
}

void inputsphere::
h (const h_type& x)
{
  this->h_.set (x);
}


// boundary
// 

const boundary::axis_type& boundary::
axis () const
{
  return this->axis_.get ();
}

boundary::axis_type& boundary::
axis ()
{
  return this->axis_.get ();
}

void boundary::
axis (const axis_type& x)
{
  this->axis_.set (x);
}

void boundary::
axis (::std::auto_ptr< axis_type > x)
{
  this->axis_.set (x);
}

const boundary::position_up_type& boundary::
position_up () const
{
  return this->position_up_.get ();
}

boundary::position_up_type& boundary::
position_up ()
{
  return this->position_up_.get ();
}

void boundary::
position_up (const position_up_type& x)
{
  this->position_up_.set (x);
}

const boundary::type_type& boundary::
type () const
{
  return this->type_.get ();
}

boundary::type_type& boundary::
type ()
{
  return this->type_.get ();
}

void boundary::
type (const type_type& x)
{
  this->type_.set (x);
}

void boundary::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// boundaryType
//

boundaryType::
boundaryType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_boundaryType_convert ();
}

boundaryType::
boundaryType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_boundaryType_convert ();
}

boundaryType::
boundaryType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_boundaryType_convert ();
}

boundaryType* boundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryType (*this, f, c);
}

boundaryType::value boundaryType::
_xsd_boundaryType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundaryType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_boundaryType_indexes_,
                    _xsd_boundaryType_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_boundaryType_indexes_ + 5 || _xsd_boundaryType_literals_[*i] != *this)
  {

    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const boundaryType::
_xsd_boundaryType_literals_[5] =
{
  "periodic",
  "outflow",
  "heating",
  "reflecting",
  "force"
};

const boundaryType::value boundaryType::
_xsd_boundaryType_indexes_[5] =
{
  ::boundaryType::force,
  ::boundaryType::heating,
  ::boundaryType::outflow,
  ::boundaryType::periodic,
  ::boundaryType::reflecting

};

// coordinate
//

coordinate::
coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_coordinate_convert ();
}

coordinate::
coordinate (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_coordinate_convert ();
}

coordinate::
coordinate (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_coordinate_convert ();
}

coordinate* coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class coordinate (*this, f, c);
}

coordinate::value coordinate::
_xsd_coordinate_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_coordinate_literals_);
  const value* i (::std::lower_bound (
                    _xsd_coordinate_indexes_,
                    _xsd_coordinate_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_coordinate_indexes_ + 3 || _xsd_coordinate_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const coordinate::
_xsd_coordinate_literals_[3] =
{
  "x",
  "y",
  "z"
};

const coordinate::value coordinate::
_xsd_coordinate_indexes_[3] =
{
  ::coordinate::x,
  ::coordinate::y,
  ::coordinate::z
};

// dimension
//

dimension::
dimension (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
{
}

dimension::
dimension (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
{
}

dimension::
dimension (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

dimension* dimension::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimension (*this, f, c);
}

// thermostatType
//

thermostatType::
thermostatType (const initialTemperature_type& initialTemperature,
                const frequency_type& frequency)
: ::xml_schema::type (),
  change_ (::xml_schema::flags (), this),
  initialTemperature_ (initialTemperature, ::xml_schema::flags (), this),
  frequency_ (frequency, ::xml_schema::flags (), this)
{
}

thermostatType::
thermostatType (const thermostatType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  change_ (x.change_, f, this),
  initialTemperature_ (x.initialTemperature_, f, this),
  frequency_ (x.frequency_, f, this)
{
}

thermostatType::
thermostatType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  change_ (f, this),
  initialTemperature_ (f, this),
  frequency_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void thermostatType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // change
    //
    if (n.name () == "change" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< change_type > r (
        change_traits::create (i, f, this));

      if (!this->change_)
      {
        this->change_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "initialTemperature" && n.namespace_ ().empty ())
    {
      this->initialTemperature_.set (initialTemperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      this->frequency_.set (frequency_traits::create (i, f, this));
      continue;
    }
  }

  if (!initialTemperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "initialTemperature",
      "");
  }

  if (!frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "frequency",
      "");
  }
}

thermostatType* thermostatType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermostatType (*this, f, c);
}

thermostatType::
~thermostatType ()
{
}

// materialType
//

materialType::
materialType (const epsilon_type& epsilon,
              const sigma_type& sigma,
              const mass_type& mass)
: ::xml_schema::type (),
  epsilon_ (epsilon, ::xml_schema::flags (), this),
  sigma_ (sigma, ::xml_schema::flags (), this),
  mass_ (mass, ::xml_schema::flags (), this)
{
}

materialType::
materialType (const materialType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  mass_ (x.mass_, f, this)
{
}

materialType::
materialType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  epsilon_ (f, this),
  sigma_ (f, this),
  mass_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void materialType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sigma",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mass",
      "");
  }
}

materialType* materialType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class materialType (*this, f, c);
}

materialType::
~materialType ()
{
}

// cuboidType
//

cuboidType::
cuboidType (const material_type& material,
            const x0_type& x0,
            const x1_type& x1,
            const x2_type& x2,
            const v0_type& v0,
            const v1_type& v1,
            const v2_type& v2,
            const n0_type& n0,
            const n1_type& n1,
            const n2_type& n2,
            const h_type& h)
: ::xml_schema::type (),
  material_ (material, ::xml_schema::flags (), this),
  x0_ (x0, ::xml_schema::flags (), this),
  x1_ (x1, ::xml_schema::flags (), this),
  x2_ (x2, ::xml_schema::flags (), this),
  v0_ (v0, ::xml_schema::flags (), this),
  v1_ (v1, ::xml_schema::flags (), this),
  v2_ (v2, ::xml_schema::flags (), this),
  n0_ (n0, ::xml_schema::flags (), this),
  n1_ (n1, ::xml_schema::flags (), this),
  n2_ (n2, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this)
{
}

cuboidType::
cuboidType (::std::auto_ptr< material_type >& material,
            const x0_type& x0,
            const x1_type& x1,
            const x2_type& x2,
            const v0_type& v0,
            const v1_type& v1,
            const v2_type& v2,
            const n0_type& n0,
            const n1_type& n1,
            const n2_type& n2,
            const h_type& h)
: ::xml_schema::type (),
  material_ (material, ::xml_schema::flags (), this),
  x0_ (x0, ::xml_schema::flags (), this),
  x1_ (x1, ::xml_schema::flags (), this),
  x2_ (x2, ::xml_schema::flags (), this),
  v0_ (v0, ::xml_schema::flags (), this),
  v1_ (v1, ::xml_schema::flags (), this),
  v2_ (v2, ::xml_schema::flags (), this),
  n0_ (n0, ::xml_schema::flags (), this),
  n1_ (n1, ::xml_schema::flags (), this),
  n2_ (n2, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this)
{
}

cuboidType::
cuboidType (const cuboidType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  material_ (x.material_, f, this),
  x0_ (x.x0_, f, this),
  x1_ (x.x1_, f, this),
  x2_ (x.x2_, f, this),
  v0_ (x.v0_, f, this),
  v1_ (x.v1_, f, this),
  v2_ (x.v2_, f, this),
  n0_ (x.n0_, f, this),
  n1_ (x.n1_, f, this),
  n2_ (x.n2_, f, this),
  h_ (x.h_, f, this)
{
}

cuboidType::
cuboidType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  material_ (f, this),
  x0_ (f, this),
  x1_ (f, this),
  x2_ (f, this),
  v0_ (f, this),
  v1_ (f, this),
  v2_ (f, this),
  n0_ (f, this),
  n1_ (f, this),
  n2_ (f, this),
  h_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void cuboidType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!material_.present ())
      {
        this->material_.set (r);
        continue;
      }
    }

    break;
  }

  if (!material_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "material",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x0" && n.namespace_ ().empty ())
    {
      this->x0_.set (x0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x1" && n.namespace_ ().empty ())
    {
      this->x1_.set (x1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x2" && n.namespace_ ().empty ())
    {
      this->x2_.set (x2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v0" && n.namespace_ ().empty ())
    {
      this->v0_.set (v0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v1" && n.namespace_ ().empty ())
    {
      this->v1_.set (v1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v2" && n.namespace_ ().empty ())
    {
      this->v2_.set (v2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "n0" && n.namespace_ ().empty ())
    {
      this->n0_.set (n0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "n1" && n.namespace_ ().empty ())
    {
      this->n1_.set (n1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "n2" && n.namespace_ ().empty ())
    {
      this->n2_.set (n2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      this->h_.set (h_traits::create (i, f, this));
      continue;
    }
  }

  if (!x0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x0",
      "");
  }

  if (!x1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x1",
      "");
  }

  if (!x2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x2",
      "");
  }

  if (!v0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v0",
      "");
  }

  if (!v1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v1",
      "");
  }

  if (!v2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v2",
      "");
  }

  if (!n0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n0",
      "");
  }

  if (!n1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n1",
      "");
  }

  if (!n2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n2",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "h",
      "");
  }
}

cuboidType* cuboidType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboidType (*this, f, c);
}

cuboidType::
~cuboidType ()
{
}

// change
//

change::
change (const target_type& target,
        const stepping_type& stepping,
        const steppingFrequency_type& steppingFrequency)
: ::xml_schema::type (),
  target_ (target, ::xml_schema::flags (), this),
  stepping_ (stepping, ::xml_schema::flags (), this),
  steppingFrequency_ (steppingFrequency, ::xml_schema::flags (), this)
{
}

change::
change (const change& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  target_ (x.target_, f, this),
  stepping_ (x.stepping_, f, this),
  steppingFrequency_ (x.steppingFrequency_, f, this)
{
}

change::
change (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  target_ (f, this),
  stepping_ (f, this),
  steppingFrequency_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void change::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "target" && n.namespace_ ().empty ())
    {
      this->target_.set (target_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "stepping" && n.namespace_ ().empty ())
    {
      this->stepping_.set (stepping_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "steppingFrequency" && n.namespace_ ().empty ())
    {
      this->steppingFrequency_.set (steppingFrequency_traits::create (i, f, this));
      continue;
    }
  }

  if (!target_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "target",
      "");
  }

  if (!stepping_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "stepping",
      "");
  }

  if (!steppingFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "steppingFrequency",
      "");
  }
}

change* change::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class change (*this, f, c);
}

change::
~change ()
{
}

// config
//

config::
config (const container_type& container,
        const domain_type& domain,
        const timedata_type& timedata,
        const output_type& output,
        const dim_type& dim,
        const statistics_type& statistics)
: ::xml_schema::type (),
  gravity_ (::xml_schema::flags (), this),
  container_ (container, ::xml_schema::flags (), this),
  domain_ (domain, ::xml_schema::flags (), this),
  timedata_ (timedata, ::xml_schema::flags (), this),
  thermostat_ (::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  inputfile_ (::xml_schema::flags (), this),
  inputcuboid_ (::xml_schema::flags (), this),
  inputfcc_ (::xml_schema::flags (), this),
  inputsphere_ (::xml_schema::flags (), this),
  boundary_ (::xml_schema::flags (), this),
  dim_ (dim, ::xml_schema::flags (), this),
  statistics_ (statistics, ::xml_schema::flags (), this)
{
}

config::
config (::std::auto_ptr< container_type >& container,
        ::std::auto_ptr< domain_type >& domain,
        ::std::auto_ptr< timedata_type >& timedata,
        ::std::auto_ptr< output_type >& output,
        const dim_type& dim,
        const statistics_type& statistics)
: ::xml_schema::type (),
  gravity_ (::xml_schema::flags (), this),
  container_ (container, ::xml_schema::flags (), this),
  domain_ (domain, ::xml_schema::flags (), this),
  timedata_ (timedata, ::xml_schema::flags (), this),
  thermostat_ (::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  inputfile_ (::xml_schema::flags (), this),
  inputcuboid_ (::xml_schema::flags (), this),
  inputfcc_ (::xml_schema::flags (), this),
  inputsphere_ (::xml_schema::flags (), this),
  boundary_ (::xml_schema::flags (), this),
  dim_ (dim, ::xml_schema::flags (), this),
  statistics_ (statistics, ::xml_schema::flags (), this)
{
}

config::
config (const config& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  gravity_ (x.gravity_, f, this),
  container_ (x.container_, f, this),
  domain_ (x.domain_, f, this),
  timedata_ (x.timedata_, f, this),
  thermostat_ (x.thermostat_, f, this),
  output_ (x.output_, f, this),
  inputfile_ (x.inputfile_, f, this),
  inputcuboid_ (x.inputcuboid_, f, this),
  inputfcc_ (x.inputfcc_, f, this),
  inputsphere_ (x.inputsphere_, f, this),
  boundary_ (x.boundary_, f, this),
  dim_ (x.dim_, f, this),
  statistics_ (x.statistics_, f, this)
{
}

config::
config (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  gravity_ (f, this),
  container_ (f, this),
  domain_ (f, this),
  timedata_ (f, this),
  thermostat_ (f, this),
  output_ (f, this),
  inputfile_ (f, this),
  inputcuboid_ (f, this),
  inputfcc_ (f, this),
  inputsphere_ (f, this),
  boundary_ (f, this),
  dim_ (f, this),
  statistics_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void config::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< gravity_type > r (
        gravity_traits::create (i, f, this));

      if (!this->gravity_)
      {
        this->gravity_.set (r);
        continue;
      }
    }

    // container
    //
    if (n.name () == "container" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< container_type > r (
        container_traits::create (i, f, this));

      if (!container_.present ())
      {
        this->container_.set (r);
        continue;
      }
    }

    // domain
    //
    if (n.name () == "domain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< domain_type > r (
        domain_traits::create (i, f, this));

      if (!domain_.present ())
      {
        this->domain_.set (r);
        continue;
      }
    }

    // timedata
    //
    if (n.name () == "timedata" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< timedata_type > r (
        timedata_traits::create (i, f, this));

      if (!timedata_.present ())
      {
        this->timedata_.set (r);
        continue;
      }
    }

    // thermostat
    //
    if (n.name () == "thermostat" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< thermostat_type > r (
        thermostat_traits::create (i, f, this));

      if (!this->thermostat_)
      {
        this->thermostat_.set (r);
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (r);
        continue;
      }
    }

    // inputfile
    //
    if (n.name () == "inputfile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputfile_type > r (
        inputfile_traits::create (i, f, this));

      this->inputfile_.push_back (r);
      continue;
    }

    // inputcuboid
    //
    if (n.name () == "inputcuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputcuboid_type > r (
        inputcuboid_traits::create (i, f, this));

      this->inputcuboid_.push_back (r);
      continue;
    }

    // inputfcc
    //
    if (n.name () == "inputfcc" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputfcc_type > r (
        inputfcc_traits::create (i, f, this));

      this->inputfcc_.push_back (r);
      continue;
    }

    // inputsphere
    //
    if (n.name () == "inputsphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputsphere_type > r (
        inputsphere_traits::create (i, f, this));

      this->inputsphere_.push_back (r);
      continue;
    }

    // boundary
    //
    if (n.name () == "boundary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< boundary_type > r (
        boundary_traits::create (i, f, this));

      this->boundary_.push_back (r);
      continue;
    }

    break;
  }

  if (!container_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "container",
      "");
  }

  if (!domain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain",
      "");
  }

  if (!timedata_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "timedata",
      "");
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "dim" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dim_type > r (
        dim_traits::create (i, f, this));

      this->dim_.set (r);
      continue;
    }

    if (n.name () == "statistics" && n.namespace_ ().empty ())
    {
      this->statistics_.set (statistics_traits::create (i, f, this));
      continue;
    }
  }

  if (!dim_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dim",
      "");
  }

  if (!statistics_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "statistics",
      "");
  }
}

config* config::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class config (*this, f, c);
}

config::
~config ()
{
}

// gravity
//

gravity::
gravity (const factor_type& factor,
         const axis_type& axis)
: ::xml_schema::type (),
  factor_ (factor, ::xml_schema::flags (), this),
  axis_ (axis, ::xml_schema::flags (), this)
{
}

gravity::
gravity (const gravity& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  factor_ (x.factor_, f, this),
  axis_ (x.axis_, f, this)
{
}

gravity::
gravity (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  factor_ (f, this),
  axis_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void gravity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "factor" && n.namespace_ ().empty ())
    {
      this->factor_.set (factor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axis_type > r (
        axis_traits::create (i, f, this));

      this->axis_.set (r);
      continue;
    }
  }

  if (!factor_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "factor",
      "");
  }

  if (!axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "axis",
      "");
  }
}

gravity* gravity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravity (*this, f, c);
}

gravity::
~gravity ()
{
}

// container
//

container::
container (const type_type& type,
           const cutoff_type& cutoff)
: ::xml_schema::type (),
  type_ (type, ::xml_schema::flags (), this),
  cutoff_ (cutoff, ::xml_schema::flags (), this)
{
}

container::
container (const container& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  cutoff_ (x.cutoff_, f, this)
{
}

container::
container (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  cutoff_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void container::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }

    if (n.name () == "cutoff" && n.namespace_ ().empty ())
    {
      this->cutoff_.set (cutoff_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!cutoff_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cutoff",
      "");
  }
}

container* container::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class container (*this, f, c);
}

container::
~container ()
{
}

// domain
//

domain::
domain (const size_x_type& size_x,
        const size_y_type& size_y,
        const size_z_type& size_z)
: ::xml_schema::type (),
  size_x_ (size_x, ::xml_schema::flags (), this),
  size_y_ (size_y, ::xml_schema::flags (), this),
  size_z_ (size_z, ::xml_schema::flags (), this)
{
}

domain::
domain (const domain& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  size_x_ (x.size_x_, f, this),
  size_y_ (x.size_y_, f, this),
  size_z_ (x.size_z_, f, this)
{
}

domain::
domain (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  size_x_ (f, this),
  size_y_ (f, this),
  size_z_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void domain::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "size-x" && n.namespace_ ().empty ())
    {
      this->size_x_.set (size_x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "size-y" && n.namespace_ ().empty ())
    {
      this->size_y_.set (size_y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "size-z" && n.namespace_ ().empty ())
    {
      this->size_z_.set (size_z_traits::create (i, f, this));
      continue;
    }
  }

  if (!size_x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "size-x",
      "");
  }

  if (!size_y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "size-y",
      "");
  }

  if (!size_z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "size-z",
      "");
  }
}

domain* domain::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain (*this, f, c);
}

domain::
~domain ()
{
}

// timedata
//

timedata::
timedata (const delta_type& delta,
          const end_type& end)
: ::xml_schema::type (),
  delta_ (delta, ::xml_schema::flags (), this),
  end_ (end, ::xml_schema::flags (), this)
{
}

timedata::
timedata (const timedata& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  delta_ (x.delta_, f, this),
  end_ (x.end_, f, this)
{
}

timedata::
timedata (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  delta_ (f, this),
  end_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void timedata::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "delta" && n.namespace_ ().empty ())
    {
      this->delta_.set (delta_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "end" && n.namespace_ ().empty ())
    {
      this->end_.set (end_traits::create (i, f, this));
      continue;
    }
  }

  if (!delta_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "delta",
      "");
  }

  if (!end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "end",
      "");
  }
}

timedata* timedata::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class timedata (*this, f, c);
}

timedata::
~timedata ()
{
}

// output
//

output::
output (const filebase_type& filebase,
        const frequency_type& frequency)
: ::xml_schema::type (),
  filebase_ (filebase, ::xml_schema::flags (), this),
  frequency_ (frequency, ::xml_schema::flags (), this)
{
}

output::
output (const output& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  filebase_ (x.filebase_, f, this),
  frequency_ (x.frequency_, f, this)
{
}

output::
output (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  filebase_ (f, this),
  frequency_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void output::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "filebase" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< filebase_type > r (
        filebase_traits::create (i, f, this));

      this->filebase_.set (r);
      continue;
    }

    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      this->frequency_.set (frequency_traits::create (i, f, this));
      continue;
    }
  }

  if (!filebase_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "filebase",
      "");
  }

  if (!frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "frequency",
      "");
  }
}

output* output::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output (*this, f, c);
}

output::
~output ()
{
}

// inputfile
//

inputfile::
inputfile (const name_type& name)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this)
{
}

inputfile::
inputfile (const inputfile& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

inputfile::
inputfile (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void inputfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name_.set (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

inputfile* inputfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class inputfile (*this, f, c);
}

inputfile::
~inputfile ()
{
}

// inputsphere
//

inputsphere::
inputsphere (const material_type& material,
             const x0_type& x0,
             const x1_type& x1,
             const x2_type& x2,
             const v0_type& v0,
             const v1_type& v1,
             const v2_type& v2,
             const n_type& n,
             const h_type& h)
: ::xml_schema::type (),
  material_ (material, ::xml_schema::flags (), this),
  x0_ (x0, ::xml_schema::flags (), this),
  x1_ (x1, ::xml_schema::flags (), this),
  x2_ (x2, ::xml_schema::flags (), this),
  v0_ (v0, ::xml_schema::flags (), this),
  v1_ (v1, ::xml_schema::flags (), this),
  v2_ (v2, ::xml_schema::flags (), this),
  n_ (n, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this)
{
}

inputsphere::
inputsphere (::std::auto_ptr< material_type >& material,
             const x0_type& x0,
             const x1_type& x1,
             const x2_type& x2,
             const v0_type& v0,
             const v1_type& v1,
             const v2_type& v2,
             const n_type& n,
             const h_type& h)
: ::xml_schema::type (),
  material_ (material, ::xml_schema::flags (), this),
  x0_ (x0, ::xml_schema::flags (), this),
  x1_ (x1, ::xml_schema::flags (), this),
  x2_ (x2, ::xml_schema::flags (), this),
  v0_ (v0, ::xml_schema::flags (), this),
  v1_ (v1, ::xml_schema::flags (), this),
  v2_ (v2, ::xml_schema::flags (), this),
  n_ (n, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this)
{
}

inputsphere::
inputsphere (const inputsphere& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  material_ (x.material_, f, this),
  x0_ (x.x0_, f, this),
  x1_ (x.x1_, f, this),
  x2_ (x.x2_, f, this),
  v0_ (x.v0_, f, this),
  v1_ (x.v1_, f, this),
  v2_ (x.v2_, f, this),
  n_ (x.n_, f, this),
  h_ (x.h_, f, this)
{
}

inputsphere::
inputsphere (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  material_ (f, this),
  x0_ (f, this),
  x1_ (f, this),
  x2_ (f, this),
  v0_ (f, this),
  v1_ (f, this),
  v2_ (f, this),
  n_ (f, this),
  h_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void inputsphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!material_.present ())
      {
        this->material_.set (r);
        continue;
      }
    }

    break;
  }

  if (!material_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "material",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x0" && n.namespace_ ().empty ())
    {
      this->x0_.set (x0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x1" && n.namespace_ ().empty ())
    {
      this->x1_.set (x1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x2" && n.namespace_ ().empty ())
    {
      this->x2_.set (x2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v0" && n.namespace_ ().empty ())
    {
      this->v0_.set (v0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v1" && n.namespace_ ().empty ())
    {
      this->v1_.set (v1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v2" && n.namespace_ ().empty ())
    {
      this->v2_.set (v2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "n" && n.namespace_ ().empty ())
    {
      this->n_.set (n_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      this->h_.set (h_traits::create (i, f, this));
      continue;
    }
  }

  if (!x0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x0",
      "");
  }

  if (!x1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x1",
      "");
  }

  if (!x2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x2",
      "");
  }

  if (!v0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v0",
      "");
  }

  if (!v1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v1",
      "");
  }

  if (!v2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v2",
      "");
  }

  if (!n_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "h",
      "");
  }
}

inputsphere* inputsphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class inputsphere (*this, f, c);
}

inputsphere::
~inputsphere ()
{
}

// boundary
//

boundary::
boundary (const axis_type& axis,
          const position_up_type& position_up,
          const type_type& type)
: ::xml_schema::type (),
  axis_ (axis, ::xml_schema::flags (), this),
  position_up_ (position_up, ::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this)
{
}

boundary::
boundary (const boundary& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  axis_ (x.axis_, f, this),
  position_up_ (x.position_up_, f, this),
  type_ (x.type_, f, this)
{
}

boundary::
boundary (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  axis_ (f, this),
  position_up_ (f, this),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void boundary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axis_type > r (
        axis_traits::create (i, f, this));

      this->axis_.set (r);
      continue;
    }

    if (n.name () == "position_up" && n.namespace_ ().empty ())
    {
      this->position_up_.set (position_up_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }
  }

  if (!axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "axis",
      "");
  }

  if (!position_up_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "position_up",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

boundary* boundary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary (*this, f, c);
}

boundary::
~boundary ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::config >
config_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::config > r (
    ::config_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::config >
config_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::config > r (
    ::config_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::config >
config_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::config > r (
    ::config_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::config >
config_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::config_ (isrc, f, p);
}

::std::auto_ptr< ::config >
config_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::config_ (isrc, h, f, p);
}

::std::auto_ptr< ::config >
config_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::config_ (isrc, h, f, p);
}

::std::auto_ptr< ::config >
config_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::config_ (isrc, f, p);
}

::std::auto_ptr< ::config >
config_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::config_ (isrc, h, f, p);
}

::std::auto_ptr< ::config >
config_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::config_ (isrc, h, f, p);
}

::std::auto_ptr< ::config >
config_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::config > r (
    ::config_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::config >
config_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::config > r (
    ::config_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::config >
config_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::config > r (
    ::config_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::config >
config_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::config > r (
      ::config_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "config" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::config > r (
      ::xsd::cxx::tree::traits< ::config, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "config",
    "");
}

::std::auto_ptr< ::config >
config_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "config" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::config > r (
      ::xsd::cxx::tree::traits< ::config, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "config",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

